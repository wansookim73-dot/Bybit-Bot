from __future__ import annotations

import contextlib
import inspect
import math
import os
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

from strategy.feed_types import StrategyFeed, OrderInfo

import strategy.grid_logic as gl
from strategy.grid_logic import GridLogic, GridDecision, GridOrderSpec

_FIXED_TS_DEFAULT = 1700000000.0  # deterministic fixed time for tests


def _u(x: Any) -> str:
    return str(x or "").upper().strip()


def _is_finite_number(x: Any) -> bool:
    try:
        v = float(x)
    except Exception:
        return False
    return math.isfinite(v)


def _is_finite_pos(x: Any) -> bool:
    try:
        v = float(x)
    except Exception:
        return False
    return math.isfinite(v) and v > 0.0


@contextlib.contextmanager
def freeze_gridlogic_time(fixed_ts: float = _FIXED_TS_DEFAULT) -> Iterable[None]:
    """
    GridLogic 내부에서 사용하는 time.time()/sleep()을 고정해서
    테스트 결과를 결정론적으로 만듭니다.

    - 운영 코드 변경 없음
    - 테스트 프로세스에서만 monkeypatch
    """
    old_time = getattr(gl.time, "time", None)
    old_sleep = getattr(gl.time, "sleep", None)

    def _time() -> float:
        return float(fixed_ts)

    def _sleep(_: float) -> None:
        return None

    gl.time.time = _time  # type: ignore[attr-defined]
    gl.time.sleep = _sleep  # type: ignore[attr-defined]
    try:
        yield
    finally:
        if old_time is not None:
            gl.time.time = old_time  # type: ignore[attr-defined]
        if old_sleep is not None:
            gl.time.sleep = old_sleep  # type: ignore[attr-defined]


def make_state(overrides: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    GridLogic가 state에서 참조할 가능성이 높은 키들을 '안전 기본값'으로 세팅합니다.
    실제 BotState를 강제하지 않고 dict로도 동작하도록(GridLogic 호환 헬퍼 사용 전제) 구성합니다.
    """
    # config에서 seed를 가져올 수 있으면 가져오고, 실패하면 안전 기본값 사용
    seed = 1200.0
    try:
        from config import INITIAL_SEED_USDT  # pylint: disable=import-error
        seed = float(INITIAL_SEED_USDT)
    except Exception:
        seed = 1200.0

    st: Dict[str, Any] = {
        # wave / line
        "wave_id": 1,
        "line_memory": {},

        # capital/seed (대략치)
        "total_balance": float(seed),
        "available_balance": float(seed),
        "effective_seed_total": float(seed) * 0.9,
        "allocated_seed": 0.0,
        "used_seed": 0.0,

        # positions (0 = flat)
        "pos_long_qty": 0.0,
        "pos_short_qty": 0.0,
        "pos_long_avg": 0.0,
        "pos_short_avg": 0.0,

        # escape flags
        "escape_active": False,
        "escape_mode": False,

        # timestamps
        "last_grid_ts": 0.0,
        "last_escape_ts": 0.0,
    }

    if overrides:
        st.update(overrides)

    # 방어적 보정
    if "line_memory" not in st or st["line_memory"] is None:
        st["line_memory"] = {}

    return st


def make_orderinfo(
    *,
    order_id: str = "O1",
    side: str = "BUY",
    price: float = 50000.0,
    qty: float = 0.001,
    filled_qty: float = 0.0,
    reduce_only: bool = False,
    order_type: str = "Limit",
    time_in_force: str = "PostOnly",
    tag: Optional[str] = "VERIFY_L1",
    created_ts: float = _FIXED_TS_DEFAULT,
) -> OrderInfo:
    return OrderInfo(
        order_id=str(order_id),
        side=str(side),
        price=float(price),
        qty=float(qty),
        filled_qty=float(filled_qty),
        reduce_only=bool(reduce_only),
        order_type=str(order_type),
        time_in_force=str(time_in_force),
        tag=tag,
        created_ts=float(created_ts),
    )


def make_feed(
    *,
    price: float = 50000.0,
    atr_4h_42: float = 300.0,
    state: Optional[Dict[str, Any]] = None,
    open_orders: Optional[List[OrderInfo]] = None,
    pnl_total: float = 0.0,
    pnl_total_pct: float = 0.0,
    trend_strength: str = "RANGE",  # 중요: feed_types 기본값은 STRONG_TREND(Entry 차단)
    trend_bias: str = "NONE",
    trend_valid: bool = True,
    trend_fresh: bool = True,
    trend_reason: str = "verify_l1",
) -> StrategyFeed:
    if state is None:
        state = make_state()
    if open_orders is None:
        open_orders = []

    # Build kwargs and filter by StrategyFeed.__init__ signature (compat across versions)
    kwargs = dict(
        price=float(price),
        atr_4h_42=float(atr_4h_42),
        state=state,  # type: ignore[arg-type]  # GridLogic 호환 헬퍼(dict 지원) 전제
        open_orders=open_orders,
        pnl_total=float(pnl_total),
        pnl_total_pct=float(pnl_total_pct),
        # Optional trend-gate fields (may not exist in older StrategyFeed)
        trend_strength=trend_strength,
        trend_bias=trend_bias,
        trend_valid=bool(trend_valid),
        trend_fresh=bool(trend_fresh),
        trend_reason=str(trend_reason),
    )

    # Remove keys not accepted by the current StrategyFeed signature
    import inspect
    sig = inspect.signature(StrategyFeed)
    accepted = set(sig.parameters.keys())
    kwargs = {k: v for k, v in kwargs.items() if k in accepted}

    return StrategyFeed(**kwargs)


def _instantiate_gridlogic() -> Any:
    """
    GridLogic 생성자 시그니처가 바뀌어도 최대한 자동 적응.
    (운영 코드 변경 없이 테스트 쪽에서만 대응)
    """
    try:
        return GridLogic()
    except TypeError:
        sig = inspect.signature(GridLogic)
        kwargs: Dict[str, Any] = {}
        for name, param in sig.parameters.items():
            if param.default is not inspect._empty:
                continue

            lname = name.lower()
            if "symbol" in lname or "pair" in lname:
                kwargs[name] = os.getenv("VERIFY_SYMBOL", "BTCUSDT")
            elif "dry" in lname:
                kwargs[name] = True
            elif "capital" in lname:
                # CapitalManager가 무조건 필요하면 여기서 주입 시도
                try:
                    from strategy.capital import CapitalManager  # pylint: disable=import-error
                    kwargs[name] = CapitalManager()
                except Exception:
                    kwargs[name] = None
            else:
                # 모르는 필수 인자는 None으로 두고, 실패 시 에러 메시지로 유도
                kwargs[name] = None

        return GridLogic(**kwargs)


def run_gridlogic_once(feed: StrategyFeed) -> GridDecision:
    logic = _instantiate_gridlogic()
    decision = logic.process(feed)
    if not hasattr(decision, "mode"):
        raise AssertionError(f"[verify_l1] GridLogic.process returned unexpected type: {type(decision)}")
    return decision


def _cancel_id(x: Any) -> str:
    if x is None:
        return ""
    if isinstance(x, str):
        return x.strip()
    if isinstance(x, dict):
        return str(
            x.get("order_id")
            or x.get("orderId")
            or x.get("id")
            or x.get("orderID")
            or ""
        ).strip()
    return str(
        getattr(x, "order_id", None)
        or getattr(x, "orderId", None)
        or getattr(x, "id", None)
        or ""
    ).strip()


def assert_griddecision_invariants(decision: GridDecision) -> None:
    """
    L1 불변조건(의사결정 레벨):
    - decision 구조가 깨지지 않을 것
    - 주문 스펙의 가격/수량/side 기본 무결성
    - reduce_only 주문은 hedge position_idx(1/2)가 세팅될 것
    - cancel은 공백 id가 없어야 함
    """
    mode = getattr(decision, "mode", "")
    if not isinstance(mode, str) or not mode.strip():
        raise AssertionError(f"[verify_l1] decision.mode invalid: {mode!r}")

    for field in ("grid_entries", "grid_replaces", "grid_cancels", "state_updates"):
        if not hasattr(decision, field):
            raise AssertionError(f"[verify_l1] decision missing field: {field}")

    entries = list(getattr(decision, "grid_entries") or [])
    replaces = list(getattr(decision, "grid_replaces") or [])
    cancels = list(getattr(decision, "grid_cancels") or [])

    # OrderSpec invariants
    for spec in (entries + replaces):
        if not isinstance(spec, GridOrderSpec):
            raise AssertionError(f"[verify_l1] order spec type invalid: {type(spec)}")

        side = _u(getattr(spec, "side", ""))
        if side not in ("BUY", "SELL"):
            raise AssertionError(f"[verify_l1] invalid side: {getattr(spec, 'side', None)!r}")

        if not _is_finite_pos(getattr(spec, "price", None)):
            raise AssertionError(f"[verify_l1] invalid price: {getattr(spec, 'price', None)!r}")

        if not _is_finite_pos(getattr(spec, "qty", None)):
            raise AssertionError(f"[verify_l1] invalid qty: {getattr(spec, 'qty', None)!r}")

        grid_index = getattr(spec, "grid_index", None)
        if not isinstance(grid_index, int):
            raise AssertionError(f"[verify_l1] grid_index not int: {grid_index!r}")

        wave_id = getattr(spec, "wave_id", None)
        if not isinstance(wave_id, int):
            raise AssertionError(f"[verify_l1] wave_id not int: {wave_id!r}")

        step_cost = getattr(spec, "step_cost", None)
        if not isinstance(step_cost, int) or step_cost < 1 or step_cost > 2:
            raise AssertionError(f"[verify_l1] step_cost invalid (expect 1 or 2): {step_cost!r}")

        reduce_only = bool(getattr(spec, "reduce_only", False))
        position_idx = getattr(spec, "position_idx", None)
        if reduce_only and position_idx not in (1, 2):
            raise AssertionError(
                f"[verify_l1] reduce_only order must set position_idx (1=LONG,2=SHORT). got: {position_idx!r}"
            )

    # Cancel invariants
    for c in cancels:
        cid = _cancel_id(c)
        if not cid:
            raise AssertionError(f"[verify_l1] cancel item has empty id: {c!r}")


def summarize(decision: GridDecision) -> str:
    e = len(list(getattr(decision, "grid_entries") or []))
    r = len(list(getattr(decision, "grid_replaces") or []))
    c = len(list(getattr(decision, "grid_cancels") or []))
    u = len(list(getattr(decision, "state_updates") or []))
    return f"mode={getattr(decision,'mode',None)} entries={e} replaces={r} cancels={c} state_updates={u}"
